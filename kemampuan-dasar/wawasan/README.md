# **1. Information technology**
Information technology (IT) is the use of computers to create, process, store, retrieve, and exchange all kinds of data and information. IT is typically used within the 
context of business operations as opposed to personal or entertainment technologies. IT forms part of information and communications technology (ICT). An information technology 
system (IT system) is generally an information system, a communications system, or, more specifically speaking, a computer system including all hardware, software, and peripheral 
equipment operated by a limited group of IT users. Humans have been storing, retrieving, manipulating, and communicating information since the Sumerians in Mesopotamia developed 
writing in about 3000 BC. However, the term information technology in its modern sense first appeared in a 1958 article published in the Harvard Business Review.
Ideas of computer science were first mentioned before the 1950s under the Massachusetts Institute of Technology (MIT) and Harvard University, where they had discussed and began 
thinking of computer circuits and numerical calculations. As time went on, the field of information technology and computer science became more complex and was able to handle the 
processing of more data. Scholarly articles began to be published from different organizations. Electronic computers, using either relays or valves, began to appear in the early 1940s. 
The electromechanical Zuse Z3, completed in 1941, was the world's first programmable computer, and by modern standards one of the first machines that could be considered a complete 
computing machine. During the Second World War, Colossus developed the first electronic digital computer to decrypt German messages. Although it was programmable, it was not 
general-purpose, being designed to perform only a single task. It also lacked the ability to store its program in memory; programming was carried out using plugs and switches to alter 
the internal wiring. The first recognizably modern electronic digital stored-program computer was the Manchester Baby, which ran its first program on 21 June 1948.
By the year of 1984, according to the National Westminster Bank Quarterly Review, the term 'information technology' had been redefined as "The development of cable television was made 
possible by the convergence of telecommunications and computing technology (…generally known in Britain as information technology).” We then begin to see the appearance of the term in 
1990 contained within documents for the International Organization for Standardization (ISO). Innovations in technology have already revolutionized the world by the twenty-first century 
as people were able to access different online services. This has changed the workforce drastically as thirty percent of U.S. workers were already in careers of this profession. 136.9 
million people were personally connected to the Internet, which was equivalent to 51 million households. Along with Internet, new types of technology were also being introduced 
across the globe, which has improved efficiency and made things easier across the globe. Along with technology revolutionizing society, millions of processes could be done in seconds. 
Innovations in communication were also crucial as people began to rely on the computer to communicate through telephone lines and cable. The introduction of email was a really big thing 
as "companies in one part of the world could communicate by e-mail with suppliers and buyers in another part of the world... Not only personally, computers and technology have also 
revolutionized the marketing industry, resulting in more buyers of their products. During the year of 2002, Americans have exceeded $28 billion in goods just over the Internet alone 
when e-commerce a decade later resulted in $289 billion in sales. And as computers are rapidly becoming more sophisticated by the day, they are becoming more used as people are 
becoming more reliant on them during the twenty-first century.
### **Electronic Data Processing**
- Data Storage
- Database
- Data Retrieval
- Data Manipulation
- Database Problem
  ### **Service**
- Email
- Search System

# **2. What's the difference between Computer Science and Informatics?**
- Computer science is the study of the theory, experimentation, and engineering that form the basis for the design and use of computers. It is the scientific and practical 
	  approach to computation and its applications and the systematic study of the feasibility, structure, expression, and mechanization of the methodical procedures (or algorithms) 
	  that underlie the acquisition, representation, processing, storage, communication of, and access to information. An alternate, more succinct definition of computer science is the 
	  study of automating algorithmic processes that scale. A computer scientist specializes in the theory of computation and the design of computational systems.
- Informatics is a branch of information engineering. It involves the practice of information processing and the engineering of information systems, and as an academic field it is 
	  an applied form of information science. The field considers the interaction between humans and information alongside the construction of interfaces, organisations, technologies 
	  and systems. As such, the field of informatics has great breadth and encompasses many subspecialties, including disciplines of computer science, information systems, information 
	  technology and statistics. Since the advent of computers, individuals and organizations increasingly process information digitally. This has led to the study of informatics with 
	  computational, mathematical, biological, cognitive and social aspects, including study of the social impact of information technologies.

# **3. Software development** 
Softare development is the process of conceiving, specifying, designing, programming, documenting, testing, and bug fixing involved in creating and maintaining applications, 
frameworks, or other software components. Software development involves writing and maintaining the source code, but in a broader sense, it includes all processes from the conception 
of the desired software through to the final manifestation of the software, typically in a planned and structured process. Software development also includes research, new development, 
prototyping, modification, reuse, re-engineering, maintenance, or any other activities that result in software products.
One system development methodology is not necessarily suitable for use by all projects. Each of the available methodologies are best suited to specific kinds of projects, based 
on various technical, organizational, project, and team considerations.
- Software development activities
Identification of need
The sources of ideas for software products are plentiful. These ideas can come from market research including the demographics of potential new customers, existing customers, sales 
prospects who rejected the product, other internal software development staff, or a creative third party. Ideas for software products are usually first evaluated by marketing personnel 
for economic feasibility, for fit with existing channels distribution, for possible effects on existing product lines, required features, and for fit with the company's marketing 
objectives. In a marketing evaluation phase, the cost and time assumptions become evaluated. A decision is reached early in the first phase as to whether, based on the more detailed 
information generated by the marketing and development staff, the project should be pursued further.
- Planning Process
Planning is an objective of each and every activity, where we want to discover things that belong to the project. An important task in creating a software program is extracting the 
requirements or requirements analysis. Customers typically have an abstract idea of what they want as an end result but do not know what software should do. Skilled and experienced 
software engineers recognize incomplete, ambiguous, or even contradictory requirements at this point. Frequently demonstrating live code may help reduce the risk that the requirements 
are incorrect.
"Although much effort is put in the requirements phase to ensure that requirements are complete and consistent, rarely that is the case; leaving the software design phase as the most 
influential one when it comes to minimizing the effects of new or changing requirements. Requirements volatility is challenging because they impact future or already going development 
efforts.
### **Software development vs. Web development**
In computer programming both software development and web development refers to the same engineer or programmer and the process of coding.
Note: software programs, esp. mobile apps can operate on the web.

Software development is focused on the programs (or software) used in computer systems. Software developers are responsible for the concept, creation, programming, some documenting, 
testing, improving and maintaining the software and its software components.
Software developers (and mobile software engineers) create programs and mobile applications for stand-alone desktop computers and mobile devices and their platforms.
Software developers need to have understanding of not only development best practices, but also the theory behind the programming.
Web developers use coding and writing markup to create interactive webpages.
Web development can be divided into two separates, the client side and server side. Client-side programming is responsible for every element that users can directly access on the web 
page, and the client-side systems allow the users to tell the webpage what they want it to do, while the server-side systems are responsible for fulfilling those requests.

### **Subtopics**
- View model
A view model is a framework that provides the viewpoints on the system and its environment, to be used in the software development process. It is a graphical representation of the 
underlying semantics of a view. The purpose of viewpoints and views is to enable human engineers to comprehend very complex systems and to organize the elements of the problem around 
domains of expertise. In the engineering of physically intensive systems, viewpoints often correspond to capabilities and responsibilities within the engineering organization.
- Business process and data modelling
Graphical representation of the current state of information provides a very effective means for presenting information to both users and system developers. example of the interaction 
between business process and data models.
A business model illustrates the functions associated with the business process being modeled and the organizations that perform these functions. By depicting activities and information 
flows, a foundation is created to visualize, define, understand, and validate the nature of a process.
A data model provides the details of information to be stored and is of primary use when the final product is the generation of computer software code for an application or the 
preparation of a functional specification to aid a computer software make-or-buy decision. See the figure on the right for an example of the interaction between business process and 
data models.
- Computer-aided software engineering
Computer-aided software engineering (CASE), in the field software engineering, is the scientific application of a set of software tools and methods to the development of software which 
results in high-quality, defect-free, and maintainable software products. It also refers to methods for the development of information systems together with automated tools that 
can be used in the software development process. The term "computer-aided software engineering" (CASE) can refer to the software used for the automated development of systems 
software, i.e., computer code. The CASE functions include analysis, design, and programming. CASE tools automate methods for designing, documenting, and producing structured computer 
code in the desired programming language.
Two key ideas of Computer-aided Software System Engineering (CASE) are:
		Foster computer assistance in software development and software maintenance processes, and
		An engineering approach to software development and maintenance.
Typical CASE tools exist for configuration management, data modeling, model transformation, refactoring, source code generation.
- Modeling language
A modeling language is any artificial language that can be used to express information or knowledge or systems in a structure that is defined by a consistent set of rules. The rules 
are used for interpretation of the meaning of components in the structure. A modeling language can be graphical or textual.
- Programming paradigm
A programming paradigm is a fundamental style of computer programming, which is not generally dictated by the project management methodology (such as waterfall or agile). 
Paradigms differ in the concepts and abstractions used to represent the elements of a program (such as objects, functions, variables, constraints) and the steps that comprise a 
computation (such as assignations, evaluation, continuations, data flows). Sometimes the concepts asserted by the paradigm are utilized cooperatively in high-level system architecture 
design; in other cases, the programming paradigm's scope is limited to the internal structure of a particular program or module. Example: Grady Booch's object-oriented design (OOD), 
also known as object-oriented analysis and design (OOAD). The Booch model includes six diagrams: class, object, state transition, interaction, module, and process.

* Software engineering *
Software engineering is a systematic engineering approach to software development.
A software engineer is a person who applies the principles of software engineering to design, develop, maintain, test, and evaluate computer software. The term programmer is sometimes 
used as a synonym, but may also lack connotations of engineering education or skills.
Engineering techniques are used to inform[clarification needed] the software development process which involves the definition, implementation, assessment, measurement, management, 
change, and improvement of the software life cycle process itself. It heavily uses software configuration management which is about systematically controlling changes to the 
configuration, and maintaining the integrity and traceability of the configuration and code throughout the system life cycle. Modern processes use software versioning.
- Etymology of "software engineer"
Margaret Hamilton promoted the term "software engineering" during her work on the Apollo program. The term "engineering" was used to acknowledge that the work should be taken just as 
seriously as other contributions toward the advancement of technology. Hamilton details her use of the term:
When I first came up with the term, no one had heard of it before, at least in our world. It was an ongoing joke for a long time. They liked to kid me about my radical ideas. It was a 
memorable day when one of the most respected hardware gurus explained to everyone in a meeting that he agreed with me that the process of building software should also be considered an 
engineering discipline, just like with hardware. Not because of his acceptance of the new "term" per se, but because we had earned his and the acceptance of the others in the room as 
being in an engineering field in its own right.
	- Software requirements
	- Software design
	- Software construction
	- Software testing
	- Software maintenance
- Software engineering degree programs
Half of all practitioners today have degrees in computer science, information systems, or information technology. A small, but growing, number of practitioners have 
software engineering degrees. In 1987, the Department of Computing at Imperial College London introduced the first three-year software engineering Bachelor's degree in the UK and the 
world; in the following year, the University of Sheffield established a similar program. In 1996, the Rochester Institute of Technology established the first software engineering 
bachelor's degree program in the United States, however, it did not obtain ABET accreditation until 2003, the same time as Rice University, Clarkson University, Milwaukee School of 
Engineering and Mississippi State University obtained theirs. In 1997, PSG College of Technology in Coimbatore, India was the first to start a five-year integrated Master of Science 
degree in Software Engineering.

# **4. Agile software development**
In software development, agile (sometimes written Agile) practices include requirements discovery and solutions improvement through the collaborative effort of self-organizing and 
cross-functional teams with their customer(s)/end user(s), adaptive planning, evolutionary development, early delivery, continual improvement, and flexible responses to changes in 
requirements, capacity, and understanding of the problems to be solved.
Popularized in the 2001 Manifesto for Agile Software Development, these values and principles were derived from and underpin a broad range of software development frameworks, 
including Scrum and Kanban.
While there is much anecdotal evidence that adopting agile practices and values improves the effectiveness of software professionals, teams and organizations, the empirical evidence is 
mixed and hard to find.
- Agile software development values
Based on their combined experience of developing software and helping others do that, the authors of the manifesto declared that they valued:
	- Individuals and interactions over processes and tools
	- Working software over comprehensive documentation
	- Customer collaboration over contract negotiation
	- Responding to change over following a plan
That is to say, while both sides have value and the items on the right should be considered, the authors felt that the items on the left should have more influence on how people 
approach their work.
As Scott Ambler explained:
	- Tools and processes are important, but it is more important to have competent people working together effectively.
	- Good documentation is useful in helping people to understand how the software is built and how to use it, but the main point of development is to create software, not documentation.
	- A contract is important but is no substitute for working closely with customers to discover what they need.
	- A project plan is important, but it must not be too rigid to accommodate changes in technology or the environment, stakeholders' priorities, and people's understanding of the problem and its solution.
- Agile software development principles
The Manifesto for Agile Software Development is based on twelve principles:
	- Customer satisfaction by early and continuous delivery of valuable software.
	- Welcome changing requirements, even in late development.
	- Deliver working software frequently (weeks rather than months).
	- Close, daily cooperation between business people and developers.
	- Projects are built around motivated individuals, who should be trusted.
	- Face-to-face conversation is the best form of communication (co-location).
	- Working software is the primary measure of progress.
	- Sustainable development, able to maintain a constant pace.
	- Continuous attention to technical excellence and good design.
	- Simplicity—the art of maximizing the amount of work not done—is essential.
	- Best architectures, requirements, and designs emerge from self-organizing teams.
	- Regularly, the team reflects on how to become more effective, and adjusts accordingly.
- Iterative, incremental, and evolutionary
Most agile development methods break product development work into small increments that minimize the amount of up-front planning and design. Iterations, or sprints, are short time 
frames (timeboxes) that typically last from one to four weeks. Each iteration involves a cross-functional team working in all functions: planning, analysis, design, coding, unit 
testing, and acceptance testing.
- Efficient and face-to-face communication
The 6th principle of the agile manifesto for software development states "The most efficient and effective method of conveying information to and within a development team is 
face-to-face conversation". The manifesto, written in 2001 when video conferencing was not widely used, states this in relation to the communication of information, not necessarily 
that a team should be co-located.
- Adaptive vs. predictive
Adaptive methods focus on adapting quickly to changing realities. When the needs of a project change, an adaptive team changes as well. An adaptive team has difficulty describing exactly 
what will happen in the future. The further away a date is, the more vague an adaptive method is about what will happen on that date. An adaptive team cannot report exactly what tasks 
they will do next week, but only which features they plan for next month. When asked about a release six months from now, an adaptive team might be able to report only the mission 
statement for the release, or a statement of expected value vs. cost.
Predictive methods, in contrast, focus on analysing and planning the future in detail and cater for known risks. In the extremes, a predictive team can report exactly what features and 
tasks are planned for the entire length of the development process. Predictive methods rely on effective early phase analysis and if this goes very wrong, the project may have difficulty 
changing direction. Predictive teams often institute a change control board to ensure they consider only the most valuable changes.
- Large-scale, offshore and distributed
Agile software development has been widely seen as highly suited to certain types of environments, including small teams of experts working on greenfield projects, and the 
challenges and limitations encountered in the adoption of agile software development methods in a large organization with legacy infrastructure are well-documented and understood.
- Experience and adoption
Although agile software development methods can be used with any programming paradigm or language in practice, they were originally closely associated with object-oriented environments 
such as Smalltalk, Lisp and later Java, C#. The initial adopters of agile methods were usually small to medium-sized teams working on unprecedented systems with requirements that were 
difficult to finalize and likely to change as the system was being developed. This section describes common problems that organizations encounter when they try to adopt agile software 
development methods as well as various techniques to measure the quality and performance of agile teams.
- Agile management
Agile project management is an iterative development process, where feedback is continuously gathered from users and stakeholders to create the right user experience. Different methods 
can be used to perform an agile process, these include scrum, extreme programming, lean and kanban.[104] The term agile management is applied to an iterative, incremental method of 
managing the design and build activities of engineering, information technology and other business areas that aim to provide new product or service development in a highly flexible and 
interactive manner, based on the principles expressed in the Manifesto for Agile Software Development.[105] Agile project management metrics help reduce confusion, identify weak points, 
and measure team's performance throughout the development cycle. Supply chain agility is the ability of a supply chain to cope with uncertainty and variability on offer and demand. 
An agile supply chain can increase and reduce its capacity rapidly, so it can adapt to a fast-changing customer demand. Finally, strategic agility is the ability of an organisation to 
change its course of action as its environment is evolving. The key for strategic agility is to recognize external changes early enough and to allocate resources to adapt to these 
changing environments.

# **5. Scrum (software development)**
Scrum or SCRUM, is a framework for project management, with an initial emphasis on software development, although it has been used in other fields including research, sales, 
marketing and advanced technologies. It is designed for teams of ten or fewer members, who break their work into goals that can be completed within time-boxed iterations, called 
sprints, no longer than one month and most commonly two weeks. The scrum team assesses progress in time-boxed daily meetings of 15 minutes or fewer, called daily scrums 
(a form of stand-up meeting). At the end of the sprint, the team holds two further meetings: the sprint review which demonstrates the work done to stakeholders to elicit feedback, and 
sprint retrospective which enables the team to reflect and improve. Hirotaka Takeuchi and Ikujiro Nonaka introduced the term scrum in the context of product development in their 1986 
Harvard Business Review article, 'The New New Product Development Game'. Takeuchi and Nonaka later argued in The Knowledge Creating Company that it is a form of "organizational 
knowledge creation, especially good at bringing about innovation continuously, incrementally and spirally".
### **Scrum team**
- Product owner
- Developers
- Scrum Master
### **Workflow**
- Sprint
- Sprint Planning
- Daily Scrum
- Sprint Review
- Sprint retrospective
- Backlog refinement
- Canceling a sprint
### **Artifacts**
- Product backlog
- Managenent
- Sprint backlog
- Increment
- Extensions
- Burndown chart
- Release burn-up chart
- Definition of ready (DoR)
- Definition of Done (DoD)
- Velocity
- Spike
- Tracer bullet
- Scrum values

Scrum is a feedback-driven empirical approach which is, like all empirical process control, underpinned by the three pillars of transparency, inspection, and adaptation. All work within 
the scrum framework should be visible to those responsible for the outcome: the process, the workflow, progress, etc. In order to make these things visible, scrum teams need to 
frequently inspect the product being developed and how well the team is working. With frequent inspection, the team can spot when their work deviates outside of acceptable limits and 
adapt their process or the product under development.

These three pillars require trust and openness in the team, which the following five values of scrum enable:

- Commitment: Team members individually commit to achieving their team goals, each and every sprint.
- Courage: Team members know they have the courage to work through conflict and challenges together so that they can do the right thing.
- Focus: Team members focus exclusively on their team goals and the sprint backlog; there should be no work done other than through their backlog.
- Openness: Team members and their stakeholders agree to be transparent about their work and any challenges they face.
- Respect: Team members respect each other to be technically capable and to work with good intent.

- Adaptation
Scrum is used in a variety of contexts to achieve many different aims. To accomplish those varying ends, Scrum is frequently tailored or adapted. A common approach to adapting Scrum 
is hybridization of scrum with other software development methodologies as scrum does not cover the whole product development lifecycle; therefore, organizations find the need to add in 
additional processes to create a more comprehensive implementation. For example, at the start of product development, organizations commonly add process guidance on the business case, 
requirements gathering and prioritization, initial high-level design, and budget and schedule forecasting.
	- Scrumban
	- Scrum of scrums
	- Large-scale scrum

# **6. Extreme programming**
Extreme programming (XP) is a software development methodology intended to improve software quality and responsiveness to changing customer requirements. As a type of agile software 
development, it advocates frequent releases in short development cycles, intended to improve productivity and introduce checkpoints at which new customer requirements can be 
adopted.

Other elements of extreme programming include: programming in pairs or doing extensive code review, unit testing of all code, not programming features until they are actually needed, 
a flat management structure, code simplicity and clarity, expecting changes in the customer's requirements as time passes and the problem is better understood, and frequent communication 
with the customer and among programmers. The methodology takes its name from the idea that the beneficial elements of traditional software engineering practices are taken 
to "extreme" levels. As an example, code reviews are considered a beneficial practice; taken to the extreme, code can be reviewed continuously (i.e. the practice of pair programming).

- History
Kent Beck developed extreme programming during his work on the Chrysler Comprehensive Compensation System (C3) payroll project.[5] Beck became the C3 project leader in March 1996. 
He began to refine the development methodology used in the project and wrote a book on the methodology (Extreme Programming Explained, published in October 1999). Chrysler 
cancelled the C3 project in February 2000, after seven years, when Daimler-Benz acquired the company. Ward Cunningham was another major influence on XP.
Many extreme-programming practices have been around for some time; the methodology takes "best practices" to extreme levels. For example, the "practice of test-first development, 
planning and writing tests before each micro-increment" was used as early as NASA's Project Mercury, in the early 1960s. To shorten the total development time, some formal test 
documents (such as for acceptance testing) have been developed in parallel with (or shortly before) the software being ready for testing. A NASA independent test group can write the 
test procedures, based on formal requirements and logical limits, before programmers write the software and integrate it with the hardware. XP takes this concept to the extreme level, 
writing automated tests (sometimes inside software modules) which validate the operation of even small sections of software coding, rather than only testing the larger features.

- Concept
	- Goals
	- Activities
	- Coding
	- Testing
	- Listening
	- Designing
	- Values
	- Communaction
	- Simplicity
	- Feedback
	- Courage
	- Respect
	- Rules

- Practices
Further information: Extreme programming practices.
Extreme programming has been described as having 12 practices, grouped into four areas:

- Fine-scale feedback
	- Pair programming
	- Planning game
	- Test-driven development
	- Whole team
- Continuous process
	- Continuous integration
	- Refactoring or design improvement
	- Small releases
- Shared understanding
	- Coding standards
	- Collective code ownership
	- Simple design
	- System metaphor
- Programmer welfare
	- Sustainable pace

Controversial aspects
The practices in XP have been heavily debated. Proponents of extreme programming claim that by having the on-site customer request changes informally, the process becomes flexible, 
and saves the cost of formal overhead. Critics of XP claim this can lead to costly rework and project scope creep beyond what was previously agreed or funded
- Scalability
Thoughtworks has claimed reasonable success on distributed XP projects with up to sixty people.
In 2004, industrial extreme programming (IXP) was introduced as an evolution of XP. It is intended to bring the ability to work in large and distributed teams. It now has 23 
practices and flexible values.
- Severability and responses
In 2003, Matt Stephens and Doug Rosenberg published Extreme Programming Refactored: The Case Against XP, which questioned the value of the XP process and suggested ways in which it 
could be improved. This triggered a lengthy debate in articles, Internet newsgroups, and web-site chat areas. The core argument of the book is that XP's practices are interdependent 
but that few practical organizations are willing/able to adopt all the practices; therefore the entire process fails. The book also makes other criticisms, and it draws a likeness 
of XP's "collective ownership" model to socialism in a negative manner.
Certain aspects of XP have changed since the publication of Extreme Programming Refactored; in particular, XP now accommodates modifications to the practices as long as the required 
objectives are still met. XP also uses increasingly generic terms for processes. Some argue that these changes invalidate previous criticisms; others claim that this is simply watering 
the process down.
Other authors have tried to reconcile XP with the older methodologies in order to form a unified methodology. Some of these XP sought to replace, such as the waterfall methodology; 
example: Project Lifecycles: Waterfall, Rapid Application Development (RAD), and All That. JPMorgan Chase & Co. tried combining XP with the computer programming methods of capability 
maturity model integration (CMMI), and Six Sigma. They found that the three systems reinforced each other well, leading to better development, and did not mutually contradict.